<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ngClass用法</title>
      <link href="/2019/03/07/angular/ngclass-yong-fa/"/>
      <url>/2019/03/07/angular/ngclass-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="ngClass用法，用于不通过情况更改不同的class"><a href="#ngClass用法，用于不通过情况更改不同的class" class="headerlink" title="ngClass用法，用于不通过情况更改不同的class"></a>ngClass用法，用于不通过情况更改不同的class</h2><h4 id="1-绑定一个字符串，就像绑定一个class一样"><a href="#1-绑定一个字符串，就像绑定一个class一样" class="headerlink" title="1. 绑定一个字符串，就像绑定一个class一样"></a>1. 绑定一个字符串，就像绑定一个class一样</h4><blockquote><p>html<br><code>`</code><br>  </p><p [ngclass]=" class1 class2 " class=" class3 "></p></blockquote><pre><code>&gt; css</code></pre><p>.class1 {  color : red }<br>.class2 {  width : 10px }<br>.class3 {  height : 10px }</p><pre><code>#### 2.  绑定一个数组&gt;html </code></pre><p> &lt;p  [ ngClass] = [“ class1”, “class2 “]  class = “ class3 “ &gt;</p><pre><code>&gt; css</code></pre><p>.class1 {  color : red }<br>.class2 {  width : 10px }<br>.class3 {  height : 10px }</p><pre><code>#### 3. 绑定一个对象：&gt;html </code></pre><p> <div (click)="changeP()''">更改p的样式</div><br> </p><p [="" ngclass]="{ 'class1' ： true ,  'class2' : false , 'class3' :showThree }"></p><pre><code>&gt; css</code></pre><p>.class1 {  color : red }<br>.class2 {  width : 10px }<br>.class3 {  height : 10px }</p><pre><code>&gt; ts</code></pre><p>public showThree :boolean = true ;</p><pre><code> class1为 true所以样式是显示的， class2 为false 所以样式是没有的， class3 在ts里面赋值为 true 所以也是显示的。#### 4. 根据布尔值选择添加哪个classts</code></pre><p>  private showDet : boolean = false;<br>  clickTit(){<br>    this.showDet = !this.showDet;<br>  }</p><pre><code>html</code></pre><p>[ngClass]=”showDet ? ‘show-det’ : ‘hide-det’”<br>//多个class<br>[ngClass]=”[showDet ? ‘show-det’ : ‘hide-det’, showtit ? ‘show-tit’ : ‘hide-tit’ ]”</p><pre><code>## 别样的添加class####  1. 直接往组件最顶层添加class</code></pre><p>@Component({<br>  selector       : ‘nz-input-number’,<br>  host           : {<br>    ‘[class.ant-input-number]’         : ‘true’,<br>    ‘[class.ant-input-number-focused]’ : ‘isFocused’,<br>    ‘[class.ant-input-number-lg]’      : <code>nzSize === &#39;large&#39;</code>,<br>    ‘[class.ant-input-number-sm]’      : <code>nzSize === &#39;small&#39;</code>,<br>    ‘[class.ant-input-number-disabled]’: ‘nzDisabled’<br>  }<br>})</p><pre><code>#### 2. class.</code></pre><p>[class.ant-table-row-expanded]=”nzExpand”</p><pre><code>## 别样的添加style####  1. 直接往组件最顶层添加style</code></pre><p>@Component({<br>  selector       : ‘nz-input-number’,<br>  host       : {<br>    ‘[style.position]’ : <code>&#39;relative&#39;</code><br>  }<br>})<br><code>`</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue watch用法</title>
      <link href="/2019/01/22/vue/watch-yong-fa/"/>
      <url>/2019/01/22/vue/watch-yong-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>watch 是一个对象，它有键，有值</p></blockquote><ul><li><p>键：你要监控的东西</p></li><li><p>值：可以是三个内容</p><ul><li>函数： 当你监控的东西发生变化执行的函数，它有两个参数，一个是变化后的值，一个是旧的值。</li><li>或 函数名，它得用单引号包裹。</li><li>或 选项的对象<ul><li>handler： 其值是一个回调函数，即监听到对象属性值变化时执行的函数。 </li><li>deep: 布尔值。是否深度监听。一般可以监听到数组值的变化，但不能监听到对象属性值的变化。</li><li>immediate: 布尔值，是否以初始值作为新值执行<code>handler</code>的函数，老值则会显示为<code>undefined</code></li></ul></li></ul></li></ul><p><code>deep</code>是用来监听对象属性的变化，即：</p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    b<span class="token punctuation">:</span> <span class="token string">'xx'</span><span class="token punctuation">,</span>    c<span class="token punctuation">:</span> <span class="token string">'xx'</span><span class="token punctuation">,</span>    obj<span class="token punctuation">:</span> <span class="token punctuation">{</span>        a<span class="token punctuation">:</span> <span class="token string">'xx'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>上面<code>obj</code>对象的<code>a</code>属性，需要添加<code>deep</code>来监听</p><h5 id="1-普通的watch"><a href="#1-普通的watch" class="headerlink" title="1. 普通的watch"></a>1. 普通的<code>watch</code></h5><pre class=" language-ts"><code class="language-ts"><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        demo<span class="token punctuation">:</span> <span class="token number">0</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">demo</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-数组的watch"><a href="#2-数组的watch" class="headerlink" title="2. 数组的watch"></a>2. 数组的<code>watch</code></h5><pre class=" language-ts"><code class="language-ts"><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        demo<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>　　demo<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token function">　　　　handler</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　　　<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　　　　　<span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> n<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　　　　　　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>　　　　　　　　<span class="token punctuation">}</span>　　　　　　<span class="token punctuation">}</span>　　　　<span class="token punctuation">}</span><span class="token punctuation">,</span>　　　　deep<span class="token punctuation">:</span> <span class="token keyword">true</span>　　<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="3-对象的watch"><a href="#3-对象的watch" class="headerlink" title="3. 对象的watch"></a>3. 对象的<code>watch</code></h5><p>只要bet中的属性发生变化（可被监测到的），便会执行handler函数</p><pre class=" language-ts"><code class="language-ts"><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　<span class="token keyword">return</span> <span class="token punctuation">{</span>　　　　dog<span class="token punctuation">:</span> <span class="token punctuation">{</span>　　　　　　name<span class="token punctuation">:</span> <span class="token string">'bob'</span><span class="token punctuation">,</span>　　　　　　age<span class="token punctuation">:</span> <span class="token number">13</span>　　　　<span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>　　dog<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token function">　　　　handler</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>　　　　<span class="token punctuation">}</span><span class="token punctuation">,</span>　　　　deep<span class="token punctuation">:</span> <span class="token keyword">true</span>　　<span class="token punctuation">}</span><span class="token punctuation">}</span> </code></pre><h5 id="4-对象具体属性的watch"><a href="#4-对象具体属性的watch" class="headerlink" title="4. 对象具体属性的watch"></a>4. 对象具体属性的<code>watch</code></h5><p>如果想监测具体的属性变化，如<code>age</code>变化时，才执行handler函数，则可以利用计算属性computed做中间层。</p><pre class=" language-ts"><code class="language-ts"><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　<span class="token keyword">return</span> <span class="token punctuation">{</span>　　　  dog<span class="token punctuation">:</span> <span class="token punctuation">{</span>　　　　　　name<span class="token punctuation">:</span> <span class="token string">'bob'</span><span class="token punctuation">,</span>　　　　　　age<span class="token punctuation">:</span> <span class="token number">13</span>　　　　<span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>　　age<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　<span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token punctuation">.</span>dog<span class="token punctuation">.</span>age　　<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token function">　　age</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> 　　　　    　　<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> 方法介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue computed概念深度理解</title>
      <link href="/2019/01/22/vue/computed-gai-nian-shen-du-li-jie/"/>
      <url>/2019/01/22/vue/computed-gai-nian-shen-du-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-computed概念深度理解"><a href="#vue-computed概念深度理解" class="headerlink" title="vue computed概念深度理解"></a>vue computed概念深度理解</h2><h4 id="关于computed概念理解"><a href="#关于computed概念理解" class="headerlink" title="关于computed概念理解"></a>关于<code>computed</code>概念理解</h4><p>官方文档解释为 ==<strong>计算属性</strong>== ，其实解释为 <strong>==属性的计算==</strong> 或许更明显些，<br>是在这个函数中对 ==<strong>属性</strong>== 进行相关的计算，然后供别的地方使用。它里面的属性是绑定在vue实例中的属性，可以通过<code>this.属性名</code>进行访问。</p><p>关于属性的计算有两种写法：</p><pre class=" language-ts"><code class="language-ts"><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        deep<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>第一种</p></blockquote><pre class=" language-ts"><code class="language-ts"><span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    demoProp<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deep<span class="token operator">++</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>第二种</p></blockquote><pre class=" language-ts"><code class="language-ts"><span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    demoProp<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deep<span class="token operator">++</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>调用</p><pre class=" language-ts"><code class="language-ts"><span class="token function">creat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>demoProp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里直接用<code>this.demoProp</code>即可访问到<code>computed</code>里面的<code>demoProp</code>属性。</p><h4 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h4><p><code>computed</code>中是计算属性，是属性，而<code>metholds</code>中的是方法。两种方式的最终结果是完全相同的。  </p><p> 不同的是 <strong>计算属性是基于它们的依赖进行缓存的</strong>  </p><p> 计算属性只有它相关的依赖（变量）发生改变时才重新求值。这就意味着只要 变量还没有发生改变，多次访问属性 计算属性会立即返回之前的计算结果，而不必再次执行函数。  </p><p>例子：</p><ol><li><p>在<code>computed</code>中定义一个<code>comNow</code>的属性，</p><pre class=" language-ts"><code class="language-ts">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span> comNow<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> Data<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>在<code>metholds</code>中定义一个<code>metNow</code>的方法</p><pre class=" language-js"><code class="language-js">metholds<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token function">metNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> Data<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上返回的都是其被调用的时间，  </p></li><li><p>在生命周期<code>creat</code>中进行调用<br><code>`</code>js<br>creat(){<br> this.getTime();</p><p> let self = this;<br> function  getTime(){</p><pre><code> window.setInterval(function(){     console.log(&quot;comNow:&quot;, this.comNow, &quot;metNow:&quot;, this.metNow()) }, 1000)</code></pre><p> }<br>}</p></li></ol><pre><code>通过在`getTime`函数中定时打印出各自的返回值看是否变化。结果：```jsthis.comNow 1528440256480 this.metNow 1528440258479this.comNow 1528440256480 this.metNow 1528440259478this.comNow 1528440256480 this.metNow 15284402 60479this.comNow 1528440256480 this.metNow 1528440261479this.comNow 1528440256480 this.metNow 1528440262478this.comNow 1528440256480 this.metNow 1528440263479</code></pre><p>由上结果可以看出：<br>在<code>computed</code>中的属性<code>comNow</code>不变化，说明它不会重新被获取而是从缓存中直接读取的。<br>而<code>metholds</code>中的<code>metNow</code>一直在变化，说明其在每次被调用的时候都会重新进行计算，每当触发重新渲染时，调用方法将总会再次执行函数。</p><blockquote><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p></blockquote><p>总结： ==<code>computed</code>依赖缓存，而<code>metholds</code>却不是。==</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> vue </tag>
            
            <tag> 方法介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期</title>
      <link href="/2019/01/22/vue/vue-sheng-ming-zhou-qi/"/>
      <url>/2019/01/22/vue/vue-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<pre><code>beforeCreate</code></pre><ul><li>这一步之前当前组件对应对象会被实例化(new vue)，但是不传入数据不会进行创建组件。</li><li>组件没有被创建所以它的<code>data</code>为<code>undefined</code></li></ul><pre><code>created</code></pre><ul><li>往实例化的对象传入数据创建组件，组件创建完成</li><li>组件中已传入数据，并且创建成了完整的组件</li></ul><pre><code>beforeMount</code></pre><ul><li>组件虽然被创建完成了，但是没有放在<code>dom</code>元素上，所以不显示</li></ul><pre><code>mounted</code></pre><p>组件被放在<code>dom</code>元素上并且已渲染完成。</p><pre><code>beforeUpdate</code></pre><p>组件被更新之前</p><pre><code>updated</code></pre><p>组件被更新之后</p><pre><code>beforeDestroy</code></pre><p>组件销毁之前，很多数据都还存在，<code>dom</code>元素上还有它。</p><pre><code>destroyed</code></pre><p>组件销毁之后，在<code>dom</code>上移除了此组件并且此组件已完全销毁，如果要用只能再次重新创建。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> vue </tag>
            
            <tag> 方法介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript基本类型介绍</title>
      <link href="/2019/01/22/vue/typescript-ji-ben-lei-xing/"/>
      <url>/2019/01/22/vue/typescript-ji-ben-lei-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="1-布尔值-boolean"><a href="#1-布尔值-boolean" class="headerlink" title="1. 布尔值 boolean"></a>1. 布尔值 boolean</h4><h4 id="2-数字-number"><a href="#2-数字-number" class="headerlink" title="2. 数字  number"></a>2. 数字  number</h4><p>支持二进制、八进制、十进制和十六进制字面量</p><h4 id="3-字符串-string"><a href="#3-字符串-string" class="headerlink" title="3. 字符串 string"></a>3. 字符串 string</h4><p>除了使用双引号（”）和单引号外（’）,还可以使用<strong>模板字符串</strong>：  </p><blockquote><p>字符串用反引号包裹（<code></code>）,并以 ${ expr } 这种形式嵌入表达式(express)。表达式可以是变量或者运算表达式。</p></blockquote><ul><li>实现字符串与变量拼接<br><code>`</code><br>let name: string = ‘deepthan’;<br>let all: string = <code>my name is ${name}</code>;<br>// all -&gt;  my name is deepthan</li></ul><pre><code>其实上面的第一个字符串可以写成</code></pre><p>let name: string = <code>deepthan</code>;<br>// 字符串值为 <code></code> 包裹，和下面的字符串拼接保持一致</p><pre><code>- 实现将数字进行计算后拼接</code></pre><p>let age = 18;<br>let myAge = <code>my age is ${age+1}</code>;<br>// myAge -&gt; my age is 19 </p><pre><code>#### 4. 数组两种方式定义数组- 类型 + []  表示此数组是由这个类型组成的。</code></pre><p>let ages: number[] = [18, 19, 20]</p><pre><code>- 泛型： Array&lt;类型&gt;</code></pre><p>let ages: Array<number> = [18, 19, 20]</number></p><pre><code>#### 5. 元组 Tuple顾名思义： 各种类型元素组成的数组。</code></pre><p>let person: [string, number] = [“deepthan”, 18]</p><pre><code>但如果写成`[18, &quot;deepthan&quot;]`会报错，因为对应的类型不同。但是会有以下情况</code></pre><p>// 这样写不会报错<br>[“deepthan”, 18, “web”, “开发”] </p><pre><code>#### 6. 枚举为数值赋予名字方便取出，如果不指定则从0开始累加</code></pre><p>enum Person {Age, Weight, Height}<br>let age: Person = Person.Age;<br>// age -&gt; 0 ,这里其实是这样的: Person { age=0, Weight=1, Height=2}</p><pre><code>枚举类型可以由枚举的值得到它的名字</code></pre><p>let personKey: string = Person[1];<br>// personKey -&gt;  ‘Weight’,因为它的值是1</p><pre><code>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。</code></pre><p>enum Person {Age=18, Weight=130, Height=180}</p><pre><code>#### 7. any- 为啥用它      在编程阶段不清楚应该指定为哪个类型或者不希望类型检查器对某些值进行检查- 有啥作用      它允许你在编译时可选择地包含或移除类型检查- 实例      当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</code></pre><pre><code>let list: any[] = [1, true, &quot;free&quot;];list[1] = 100;```</code></pre><h4 id="8-void"><a href="#8-void" class="headerlink" title="8. void"></a>8. void</h4><p>它表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><pre><code>function warnUser(): void {    alert(&quot;This is my warning message&quot;);}</code></pre><p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null</p><h4 id="9-Null-和-Undefined"><a href="#9-Null-和-Undefined" class="headerlink" title="9. Null 和 Undefined"></a>9. Null 和 Undefined</h4><p>ndefined和null两者各自有自己的类型分别叫做undefined和null。<br>默认情况下null和undefined是所有类型的子类型。 就是说你可以把  null和undefined赋值给number类型的变量。</p><h4 id="10-Never"><a href="#10-Never" class="headerlink" title="10. Never"></a>10. Never</h4><p>表示那些永不存在的值的类型。</p><ul><li>never类型是任何类型的子类型，也可以赋值给任何类型；</li><li>没有任何类型是never的子类型或可以赋值给never类型（除了never本身之外）</li></ul><p>下面是一些返回never类型的函数：</p><pre><code>// 返回never的函数必须存在无法到达的终点 function error(msg: string): never{     throw new Error(msg); }</code></pre><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>什么是类型断言？<br>答：程序员指定类型而无需ts再去检查。</p><ul><li>只是进行类型转换，而不做数据检查和解构。  </li><li>它没有运行时的影响，只是在编译阶段起作用  </li><li>TypeScript会假设你，程序员，已经进行了必须的检查。  </li></ul><p>类型断言有两种形式：</p><ul><li>“尖括号”语法</li></ul><pre><code>let age: any = &#39;deepthan&#39;;let ageLength: number = (&lt;string&gt;age).length;</code></pre><ul><li>as语法</li></ul><pre><code>let age: any = &#39;deepthan&#39;;let ageLength: number = (age as string).length;</code></pre>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
